## AST-оптимизация заменой оператора присваивания вида x = x на пустой узел

### Постановка задачи
Реализовать оптимизацию по AST дереву вида x = x => null

### Команда
Карякин В.В., Карякин Д.В.

### Зависимые и предшествующие задачи
Предшествующие задачи:
* построение AST дерева
* базовые визиторы по AST дереву

### Теоретическая часть
Принцип работы данной оптимизации показан с помощью блок-схем, соответствующих некоторому поддереву абстрактного синтаксического дерева.

Ниже приведена блок-схема, которая соответствует строчке кода ```x = x;``` . Узел ```Assign``` подлежит оптимизации.

![Узлы AСT до оптимизации](1_OptAssignEquality/img1.png)

Данный узел ```Assign``` должен быть заменён на пустой узел ```EmptyNode```.
Блок-схема ниже показывает, что происходит после применения этой оптимизации.

![Узлы AСT после оптимизации](1_OptAssignEquality/img2.png)

### Практическая часть
Данная оптимизация реализована в виде визитора, унаследованного от класса `ChangeVisitor`.
В визиторе переопределяется метод `PostVisit`, таким образом, чтобы при присваивании вида `x = x` данный узел абстрактного синтаксического дерева заменялся на `EmptyNode` с помощью метода `ReplaceStat` унаследованного от класса `ChangeVisitor`.

Реализация оптимизации:
```csharp
/* OptAssignEquality.cs */
public class OptAssignEquality : ChangeVisitor
{
    public override void PostVisit(Node n)
    {
        if (n is AssignNode assignNode && assignNode.Expr is IdNode idn && assignNode.Id.Name == idn.Name)
        {
            ReplaceStat(assignNode, new EmptyNode());
        }
    }
}
```

### Место в общем проекте (Интеграция)
Данная оптимизация выполняется вместе с остальными оптимизациями по абстрактному синтаксическому дереву.
```csharp
/* ASTOptimizer.cs */
private static IReadOnlyList<ChangeVisitor> ASTOptimizations { get; } = new List<ChangeVisitor>
{
    /* ... */
    new OptAssignEquality(),
    /* ... */
};
```

### Тесты
Метод ```BuildAST``` используется для создания абстрактного синтаксического дерева по переданной ему строке кода. Схема тестирования выглядит следующим образом: сначала по заданному тексту программы генерируется AST, затем применяется оптимизация, после сравниваются строка ожидаемого результата и строка полученная с помощью визитора ```PrettyPrintVisitor``` по оптимизированному абстрактному дереву. Пустая строчка соответствуют пустому оператору. Ниже приведён один из тестов.
```csharp
[Test]
public void RemoveNode()
{
    var AST = BuildAST(@"
var a, b;
a = a;
{ b = b; }
");
    var expected = @"var a, b;

{

}";
    var opt = new OptAssignEquality();
    AST.root.Visit(opt);
    var pp = new PrettyPrintVisitor();
    AST.root.Visit(pp);
    Assert.AreEqual(expected, pp.Text);
}
```

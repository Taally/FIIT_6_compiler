## Создание базового визитора для оптимизаций абстрактного синтаксического дерева

### Постановка задачи
Написать базовый визитор, на основе которого будут создаваться визиторы оптимизаций по абстрактному синтаксическому дереву.

### Команда
Д.Володин, А.Татарова, Т.Шкуро

### Зависимые и предшествующие задачи
Предшествующие:

- Базовые визиторы
- Построение AST

Зависимые:

- Визиторы-оптимизации по AST
- Общий алгоритм оптимизации по AST

### Теоретическая часть
Для оптимизаций в AST требуется иметь функционал заменяны выражения на выражение, а также оператора на оператор. Более того, хотелось бы избежать специфичной обработки каждого вида узлов в дереве.

### Практическая часть
Для обобщения работы со всеми видами узлов в дереве, вместо специфичных каждому виду элементов (`Left`/`Right` для `BinOpNode` и т.д.) в данном визиторе используются обобщённые списки `List<ExprNode> ExprChildren`/`List<StatementNode> StatChildren`, которые хранятся во всех узлах дерева.
Таким образом, замена выражения `from` на выражение `to` тривиальна: родителем выражения `to` нужно назначить родителя выражения `from`, а далее заменить `from` на `to` в списке дочерних выражений родителя `from`.
Дополнительно класс имеет публичное свойство `Changed`, которое равно `true`, когда конкретный визитор произвёл какую-либо замену.

```csharp
public void ReplaceExpr(ExprNode from, ExprNode to)
{
    var p = from.Parent;
    to.Parent = p;
    if (p.ExprChildren.Count > 0)
    {
        for (var i = 0; i < p.ExprChildren.Count; ++i)
        {
            if (p.ExprChildren[i] == from)
            {
                p.ExprChildren[i] = to;
                Changed = true;
                break;
            }
        }
    }
    else
    {
        throw new Exception("Parent node doesn't contain expressions.");
    }
}
```

Замена операторов полностью идентична, за исключением отдельной обработки случая, когда `to` это `BlockNode`. Чтобы избежать ненужных фигурных скобок, блок заменяется на список своих операторов, а если он содержит всего лишь один оператор, то на этот оператор.
```csharp
p.StatChildren[i] = to is BlockNode block
    ? block.List.StatChildren.Count == 1
        ? block.List.StatChildren[0] : block.List
    : to;
```

### Место в общем проекте (Интеграция)
Все визиторы оптимизаций по AST наследуют данный класс.

### Тесты
Тестированию подвергаются наследники данного класса, которые реализуют конкретные оптимизации на AST.

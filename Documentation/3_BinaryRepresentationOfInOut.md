

### Представление IN OUT информации в виде битовых массивов. Интеграция данного представления в существующий итерационный алгоритм.  
  
#### Постановка задачи  

Необходимо реализовать альтернативный способ представления IN/OUT данных для итерационных алгоритмов, а затем интегрировать данный способ представления данных в какой-нибудь алгоритм.
  
#### Команда  

А.Пацеев, И.Ушаков
  
#### Зависимые и предшествующие задачи  

Предшествующие:
- Построение графа потока управления
- Вычисление передаточной функции для достигающих определений
- Итерационный алгоритм в обобщенной структуре
  
#### Теоретическая часть  

Множества IN и OUT используются в итеративных алгоритмах над CFG, например в алгоритме поиска достижимых определений.  
Данные множества вычисляются с помощью операций объединения и разности над множествами gen и kill. Поэтому представление  
этих множеств в виде битовых массивов крайне удобно для эффективной реализации.

![Формулы вычисления IN и OUT](3_BinaryRepresentationOfInOut/pic1.png)
  
#### Практическая часть  

Битовое представление IN и OUT было использовано в алгоритме ReachingDefinitions, который реализован на основе обобщенного итерационного алгоритма. По определению данного алгоритма, результатом его работы должна быть информация вида `InOutData<IEnumerable<Instruction>>`, а значит необходимо создать механизм трансляции между битовым и обычным представленим IN-OUT данных. Для этого перед запуском алгоритма создается индекс идентификаторов инструкций, с помощью которых в конце работы алгоритма можно будет преобразовать результат в надлежащий вид.

```csharp
var idByInstruction = assigns  
    .Select((value, index) => new { value, index })  
    .ToDictionary(x => x.value, x => x.index);  
  
var inOutData = base.Execute(graph); // основная логика алгоритма
  
var modifiedBackData = inOutData  
    .Select(x => new { x.Key, ModifyInOutBack = ModifyInOutBack(x.Value, instructions) })  
    .ToDictionary(x => x.Key, x => x.ModifyInOutBack);

return new InOutData<IEnumerable<Instruction>>(modifiedBackData);
```

При этом `base.Execute` будет работать на основе битовых операций. Для возможности работы данного метода с битовыми векторами необходимо было создать реализацию передаточной функции, которая создает множества Gen и Kill в виде битовых векторов, а затем использует битовы операции `Or` и `Except` для проведения вычеслений,  приведенных в формулах в теоретической части.

```csharp
private BitArray ApplyTransferFunc(BitArray @in, BasicBlock block)  
{  
    var gen = gen_block.ContainsKey(block) ? 
	    gen_block[block] : new BitArray(@in.Count, false);  
    var kill = kill_block.ContainsKey(block) ? 
	    kill_block[block] : new BitArray(@in.Count, false);  
    return gen.Or(BitUtils.Except(@in, kill));  
}
```
  
Для представления множеств Gen и Kill в виде битовых массивов используется вспомогательный метод, который на основании `idByInstruction`, вычисленному в начале работы алгоритма и информации об определениях формирует битовый массив.

```csharp
public static Dictionary<BasicBlock, BitArray> 
	GroupByBlockAndTurnIntoInstructions(  
	    IEnumerable<DefinitionInfo> defs,  
	    Dictionary<Instruction, int> idsByInstruction  
	)  
{  
    var result = defs  
        .ToLookup(x => x.BasicBlock, x => x.Instruction)  
        .ToDictionary(x => x.Key, x => TurnIntoBits(x.ToList(), idsByInstruction));  
  
    return result;  
}
```
  
#### Место в общем проекте (Интеграция)  

Реализация битового представления IN-OUT и интеграция в существующий алгоритм является вспомогательным средством, которое может быть использовано для анализа потока управления. Интеграция основана на обобщенном итерационном алгоритме. Для реализации интеграции потребовалось реализовать вспомогательные методы для операций над битовыми массивами, а так же создать способ преобразования Gen и Kill множеств в битовое представление и обратно.
  
#### Тесты  
  
Тестами покрыты как и вспомогательные битовые операции для преобразование данных, так и непосредственно сам итерационный алгоритм по поиску достигающих определений. В ходе тестов было содержимое IN и OUT для каждого базового бока программы. Примеры исходных данных для тестирования:

```
var a;  
a = 1;  
a = 2;

var a;  
a = 1;  
input(a);

var a, b;  
a = 1;  
goto 1;  
1: b = 2;

var a, b;  
input(a);  
if a > 0  
 b = 0;else  
 a = 1;b = a;

var i, k;  
for k = 0, 2  
 i = i + 1;

var a;  
1: a = 1;  
goto 1;  
a = 4;

var i, m, j, n, a, u1, u2, u3, k;  
1: i = m - 1;  
2: j = n;  
3: a = u1;  
  
for k = 0, 1 {
 i = i + 1; j = j - 1;  
 if i < j a = u2; i = u3;
}
```
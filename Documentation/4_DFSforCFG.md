### Упорядочение CFG в глубину с построением глубинного остовного дерева
#### Постановка задачи
Реализовать алгоритм упорядочения графа потока управления в глубину с построением глубинного остовного дерева.
#### Команда
Д. Лутченко, М. Письменский
#### Зависимые и предшествующие задачи
Зависимые задачи:
- Классификация рёбер графа

Предшествующая задача: 
- Построение графа потока управления

#### Теоретическая часть
Поиск в глубину — один из методов обхода графа. Стратегия поиска в глубину, как и следует из названия, состоит в том, чтобы идти «вглубь» графа, насколько это возможно. 

Примение поиска в глубину на графе потока управления, начиная с входного блока, позволяет получить глубинное остовное дерево. Упорядочение узлов в глубину представляет собой обращенный обратный порядок обхода.

#### Практическая часть

```csharp
List<int> NLR; // прямой порядок обхода
List<int> LRN; // обратный порядок обхода
List<(int, int)> DFST; // список ребер глубинного оставного дерева
List<int> DFN; // нумерация в глубину
```

Алгоритм поиска описывается рекурсивно: перебираем все исходящие из рассматриваемой вершины рёбра. Если ребро ведёт в вершину, которая не была рассмотрена ранее, то запускаем алгоритм от этой нерассмотренной вершины, а после возвращаемся и продолжаем перебирать рёбра. Возврат происходит в том случае, если в рассматриваемой вершине не осталось рёбер, которые ведут в нерассмотренную вершину.

```csharp
var used = new bool[c];

dfs = (int vertex) =>
{
    used[vertex] = true;
    NLR.Add(vertex);
    foreach ((var v, _) in children[vertex])
      if (!used[v])
      {
          DFST.Add((vertex, v));
          dfs(v);
      }
    LRN.Add(vertex);
    DFN[vertex] = --c;
};

dfs(0);
```


#### Место в общем проекте (Интеграция)

#### Тесты
Тест заключается в проверке корректности построений:
- прямого и обратного обходов
- упорядочения в глубину
- глубинного оставного дерева

```csharp
var TAC = GenTAC(@"
var a, b, c, d, x, u, e,g, y,zz,i;
goto 200;
200: a = 10 + 5;
for i=2,7 
	x = 1;
if c > a
{
	a = 1;
}
else 
{
    b = 1;
}
");

var blocks = BasicBlockLeader.DivideLeaderToLeader(TAC);
var cfg = new ControlFlowGraph(blocks);

//            0
//            ↓
//            1
//            ↓
//            2
//            ↓
//        → → 3
//        ↑  / \
//        ← 5   4
//              ↓
//              6
//             / \
//            8   7
//            ↓   ↓
//            9 ← ←
//            ↓
//            10

var nlr = new List<int>() { 0, 1, 2, 3, 5, 4, 6, 8, 9, 10, 7 };
CollectionAssert.AreEqual(nlr, cfg.NLR);


var lrn = new List<int>() { 5, 10, 9, 8, 7, 6, 4, 3, 2, 1, 0 };
CollectionAssert.AreEqual(lrn, cfg.LRN);

lrn.Reverse();

for (int i = 0; i< lrn.Count; ++i)
	Assert.AreEqual(cfg.DFN[lrn[i]], i);

var check = new bool[cfg.GetCurrentBasicBlocks().Count];
foreach ((var u, var v) in cfg.DFST)
{
	check[u] = true;
	check[v] = true;
}

foreach (var c in check)
	Assert.IsTrue(c);

Assert.AreEqual(check.Length - 1, cfg.DFST.Count);
```

## Упорядочение CFG в глубину с построением глубинного остовного дерева

### Постановка задачи
Реализовать алгоритм упорядочения графа потока управления в глубину с построением глубинного остовного дерева.

### Команда
Д. Лутченко, М. Письменский

### Зависимые и предшествующие задачи
Зависимые задачи:

- Классификация рёбер графа

Предшествующая задача: 

- Построение графа потока управления

### Теоретическая часть
Поиск в глубину — один из методов обхода графа. Стратегия поиска в глубину, как и следует из названия, состоит в том, чтобы идти «вглубь» графа, насколько это возможно. 

Применение поиска в глубину на графе потока управления, начиная с входного блока, позволяет получить глубинное остовное дерево. Упорядочение узлов в глубину представляет собой обращенный обратный порядок обхода.

### Практическая часть

```csharp
List<int> NLR; // прямой порядок обхода
List<int> LRN; // обратный порядок обхода
List<(int, int)> DFST; // список рёбер глубинного остовного дерева
List<int> DFN; // нумерация в глубину
```

Алгоритм поиска описывается рекурсивно: перебираем все исходящие из рассматриваемой вершины рёбра. Если ребро ведёт в вершину, которая не была рассмотрена ранее, то запускаем алгоритм от этой нерассмотренной вершины, а после возвращаемся и продолжаем перебирать рёбра. Возврат происходит в том случае, если в рассматриваемой вершине не осталось рёбер, которые ведут в нерассмотренную вершину.

```csharp
var used = new bool[c];

dfs = (int vertex) =>
{
    used[vertex] = true;
    NLR.Add(vertex);
    foreach ((var v, _) in children[vertex])
      if (!used[v])
      {
          DFST.Add((vertex, v));
          dfs(v);
      }
    LRN.Add(vertex);
    DFN[vertex] = --c;
};

dfs(0);
```

### Место в общем проекте (Интеграция)
Используется в измененных итерационных алгоритмах для оптимальной скорости работы.

### Тесты
Тест заключается в проверке корректности построений:

- прямого и обратного обходов
- упорядочения в глубину
- глубинного остовного дерева

```csharp
var program = @"
var a, b, c, x, i;
goto 200;
200: a = 10 + 5;
for i = 2, 7
    x = 1;
if c > a
{
    a = 1;
}
else
{
    b = 1;
}
";

var cfg = GenCFG(program);

//            0
//            ↓
//            1
//            ↓
//            2
//            ↓
//        → → 3
//        ↑  / \
//        ← 4   \
//              ↓
//              5
//             / \
//            7   6
//            ↓   ↓
//            8 ← ←
//            ↓
//            9

var nlr = new List<int>() { 0, 1, 2, 3, 5, 7, 8, 9, 6, 4 };
CollectionAssert.AreEqual(nlr, cfg.PreOrderNumeration);

var lrn = new List<int>() { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
CollectionAssert.AreEqual(lrn, cfg.PostOrderNumeration);

lrn.Reverse();

for (var i = 0; i < lrn.Count; ++i)
{
    Assert.AreEqual(cfg.DepthFirstNumeration[lrn[i]], i);
}

var check = new bool[cfg.GetCurrentBasicBlocks().Count];
foreach ((var u, var v) in cfg.DepthFirstSpanningTree)
{
    check[u] = true;
    check[v] = true;
}

foreach (var c in check)
{
    Assert.IsTrue(c);
}

Assert.AreEqual(check.Length - 1, cfg.DepthFirstSpanningTree.Count);
```

## Построение дерева доминаторов

### Постановка задачи
Необходимо по ранее созданному графу потока управления программы определить множество доминаторов для каждого базового блока, и на основе этой информации построить дерево доминаторов.

### Команда
Д. Володин, Н. Моздоров

### Зависимые и предшествующие задачи
Предшествующие: 

- Построение графа потока управления
- Итерационный алгоритм в обобщённой структуре

Зависимые:

- Обратные рёбра и определение того, что CFG является приводимым 

### Теоретическая часть
Говорят, что базовый блок *b* доминирует над базовым блоком *d*, если любой путь от входного узла в графе потока управления от входного узла к узлу *d* проходит через узел *b*. Множество доминаторов для базовых блоков программы можно найти с помощью итерационного алгоритма: множество доминаторов узла (кроме него самого) – это пересечение доминаторов всех его предшественников, оператором сбора является пересечение множеств, а передаточная функция *f_B*(*x*) = *x* ∪ {*B*}.

Отношение доминирования обладает свойством, что для любого базового блока его доминаторы образуют линейно упорядоченное множество по данному отношению. Нетрудно увидеть, что такое упорядоченное множество представляет собой путь в дереве доминаторов от корня (входного узла) к данному узлу. Анализируя эти пути, можно легко построить дерево доминаторов в графе потока управления.

### Практическая часть
Для нахождения доминаторов использовался обобщённый итерационный алгоритм, созданный ранее. Свойства, использующиеся в нём, задаются следующим образом:
```csharp
/// оператор сбора
 public override Func<IEnumerable<BasicBlock>, IEnumerable<BasicBlock>, IEnumerable<BasicBlock>> CollectingOperator
     => (x, y) => x.Intersect(y);

/// оператор сравнения (условие продолжения цикла)
public override Func<IEnumerable<BasicBlock>, IEnumerable<BasicBlock>, bool> Compare
    => (x, y) => !x.Except(y).Any() && !y.Except(x).Any();
    
/// передаточная функция
public override Func<BasicBlock, IEnumerable<BasicBlock>, IEnumerable<BasicBlock>> TransferFunction
{
    get => (block, blockList) => blockList.Union(new[] { block });
    protected set { }
}
```

Свойства ```Init``` и ```InitFirst``` зависят от графа потока управления, и они задаются во время вызова алгоритма:
```csharp
Init = graph.GetCurrentBasicBlocks();
InitFirst = graph.GetCurrentBasicBlocks().Take(1);
```
Метод ```GetDominators``` возвращает словарь, в котором ключом является базовый блок, а значением --- соответствующее OUT-множество из итерационного алгоритма.

Построение дерева доминаторов основано на том наблюдении, что, поскольку входной базовый блок доминирует над всеми остальными, базовые блоки с одинаковым количеством доминаторов будут находиться на одном слое в дереве доминаторов. Поэтому можно построить это дерево по слоям, отсортировав узлы по количеству доминаторов, и соединяя каждый последующий базовый блок с тем блоком из предыдущего слоя, который доминирует над данным. 
```csharp
var treeLayers = GetDominators(graph)
    .Where(z => z.Key != start)
    .GroupBy(z => z.Value.Count())
    .OrderBy(z => z.Key);
var tree = new Tree(start);
var prevLayer = new List<BasicBlock>(new[] { start });
foreach (var layer in treeLayers)
{
    var currLayer = layer.ToDictionary(z => z.Key, z => z.Value);
    foreach (var block in currLayer)
    {
        var parent = prevLayer.Single(z => block.Value.Contains(z));
        tree.AddNode(block.Key, parent);
    }
    prevLayer = currLayer.Keys.ToList();
}
return tree;
```
### Место в общем проекте (Интеграция)
При построении дерева доминаторов используется обобщённый итерационный алгоритм, созданный ранее для задач анализа достигающих определений, активных переменных и доступных выражений. Особенность текущего алгоритма состоит в том, что OUT-множество для входного блока инициализируется не так, как для всех остальных блоков, поэтому в обобщённый алгоритм было добавлено свойство ```InitFirst``` для инициализации OUT-множества для входного блока.

### Тесты
В тестах проверяется как построение множества доминаторов для каждого базового блока программы, так и построение дерева доминаторов. Тестирование проводится на следующих примерах:
```
var a;
```

```
var a;
a = 1;
```

```
var a, b, c, d, e, f;
1: a = 1;
b = 2;
goto 2;
2: c = 3;
d = 4;
goto 3;
3: e = 5;
goto 4;
4: f = 6;
```

```
var a;
input(a);
1: if a == 0
    goto 2;
a = 2;
2: a = 3;
```

```
var a;
input(a);
1: if a == 0
    goto 2;
if a == 1
    goto 2;
a = 2;
2: a = 3;
```

```
var a, b, c;
input(a);
b = a * a;
if b == 25
    c = 0;
else
    c = 1;
```

```
var a, b, i;
input(a);
for i = 1, 10
{
    b = b + a * a;
    a = a + 1;
}
```
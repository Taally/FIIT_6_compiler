## Определение всех естественных циклов

### Постановка задачи
Необходимо реализовать определение всех естественных циклов программы с использованием обратных ребр.

### Команда
К. Галицкий, А. Черкашин

### Зависимые и предшествующие задачи
Предшествующие задачи:
* Обратные рёбра и определение того, что CFG является приводимым
* Построение CFG. Обход потомков и обход предков для каждого ББл

Зависимые задачи
* Построение областей

### Теоретическая часть
В рамках этой задачи необходимо было реализовать определение всех естественных циклов.
Циклы в исходной программе могут определятся различными способами: как циклы `for`, `while` или же они могут быть определены с использованием меток и инструкций `goto`. С точки зрения анализа программ, не имеет значения, как именно выглядят циклы в исходном тексте программы. Важно только то, что они обладают свойствами, допускающими простую их оптимизацию. В данном случае, нас интересует, имеется ли у цикла одна точка входа, если это так, то компилятор в ходе анализа может предпологать выполнение некоторых начальных условий, в начале каждой итерации цикла. Эта возможность служит причиной определения "естественного цикла".

такие циклы обладают двумя важными свойствами:
* Цикл должен иметь единственный входной узел, называемый заголовком.
* Должно существовать обратное ребро, ведущее в заголовок цикла. В противном случае поток управления не сможет вернуться в заголовок непосредственно из "цикла", т.е. даная структура циклом в таком случае не является.

Вход алгоритма построения естественного цикла обратной дуги:
* Граф потока G и обратная дуга n -> d.
Выход:
* Множество loop, состоящее из всех узлов естественного цикла n -> d.


### Практическая часть
Реализовали метод для поиска естественных циклов, который отрабатывает только в случае, если граф является приводимым. Находим все циклы программы при промощи обратных ребер графа. Проверяем все циклы на условие естественности: цикл должен содержать только одну точку входа.
Пример реализации метода, возвращающий все естественные циклы:
```csharp
public class NaturalLoop
foreach (var (From, To) in cfg.GetBackEdges()) // проход по всем обратным ребрам
{
    if (cfg.VertexOf(To) > 0) // проверка на наличие цикла
    {
        var tmp = new List<BasicBlock>(); // временный список
        for (var i = cfg.VertexOf(To); i < cfg.VertexOf(From) + 1; i++)
        {
            if (!tmp.Contains(ForwardEdges[i])) // содержит ли список данный ББл
            {
                tmp.Add(ForwardEdges[i]);
            }
        }

        natLoops.Add(tmp);
    }
}
```
Цикл является естественным если все его ББл не содержат входы извне цикла.
Вспомогательный метод для проверки циклов на естественность:
```csharp
// если кол-во родителей больше 1, значит есть вероятность, что цикл содержит метку с переходом извне
if (parents.Count > 1)
{
    foreach (var parent in parents.Select(x => x.block)) // проверяем каждого родителя
    { // если родитель не принадлежит текущему циклу, этот цикл не является естественным
        if (!loop.Contains(parent))
        {
            return false;
        }
    }
}
```

Результат работы алгоритма :
```csharp
// Возвращаем только те циклы, которые являются естественными
return natLoops.Where(loop => IsNaturalLoop(loop, cfg)).ToList();
```

### Место в общем проекте (Интеграция)
Используется для определения всех естественных циклов программы:
```csharp
/* ... */
var natLoops = NaturalLoop.GetAllNaturalLoops(cfg);
/* ... */
```

### Тесты
В тестах проверяется определение всех естественных циклов.
```csharp
[Test]
public void IntersectLoopsTest()
{
    var TAC = GenTAC(@"
var a, b;

54: a = 5;
55: a = 6;
b = 6;
goto 54;
goto 55;
");

    var cfg = GenCFG(TAC);
    var actual = NaturalLoop.GetAllNaturalLoops(cfg);
    var expected = new List<List<BasicBlock>>()
    {
        new List<BasicBlock>()
        {
            new BasicBlock(new List<Instruction>(){ TAC[0] }),
            new BasicBlock(new List<Instruction>(){ TAC[1], TAC[2], TAC[3] }),

        }
    };

    AssertSet(expected, actual);
}

[Test]
public void NestedLoopsTest()
{
    var TAC = GenTAC(@"
var a, b;

54: a = 5;
55: a = 6;
b = 6;
goto 55;
goto 54;

");

    var cfg = GenCFG(TAC);
    var actual = NaturalLoop.GetAllNaturalLoops(cfg);
    var expected = new List<List<BasicBlock>>()
    {
        new List<BasicBlock>()
        {
            new BasicBlock(new List<Instruction>(){ TAC[1], TAC[2], TAC[3] })
        }

    };

    AssertSet(expected, actual);
}
```

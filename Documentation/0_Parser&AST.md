## Парсер языка и построение АСТ

### Постановка задачи
Написать лексер и парсер языка, используя GPLex и Yacc.
Реализовать построение абстрактного синтаксического дерева (АСТ).

### Команда
А. Татарова, Т. Шкуро, А. Пацеев

### Зависимые и предшествующие задачи
Зависимые:

- Базовые визиторы

- Генерация трехадресного кода

- Оптимизации по АСТ

### Теоретическая часть
Решением этой задачи является реализация двух составляющих: лексера и парсера.

__Лексический анализатор__ (или лексер, токенизатор) — это часть программы, выполняющая разбор входной последовательности символов на токены. 

__Синтаксический анализатор__ (или парсер) — это часть программы, преобразующая входной текст (поток токенов) в структурированный формат, в данном случае происходит преобразование в АСТ.

__Абстрактное синтаксическое дерево__ (АСТ) — это ориентированное дерево, внутренние вершины сопоставлены с операторами языка, а листья — с соответствующими операндами. 

### Практическая часть
Для реализации лексера и парсера был выбран Yacc+Lex, создающий front-end компилятора по описанию грамматики. Для этого генератора создаются два файла: SimpleLex.lex (описание лексера) и SimpleYacc.y (описание парсера). Далее генератор на основании этих файлов строит лексер и парсер на языке C#. 

### Парсер языка
Парсер был реализован для языка со следующим синтаксисом:
```csharp
var a, b, c, d; // определение переменных
```
```csharp
// присваивание
a = 11;
d = true;
```
```csharp
// операторы сравнения
d = a > 5;
d = b < a;
d = b != c;
d = a == b;
```
```csharp
// бинарные операции
a = a + 1;
b = a - 5;
c = b * a;
b = c / 2;
d = d or false;
d = d and true;
```
```csharp
// унарные операции
a = -b;
d = !(a < b);
```
```csharp
// полная форма условного оператора
if c > a
	a = c;
else {
    b = 1;
	a = b;
}
// Сокращенная форма условного оператора
if a < 1 
	c = 5 + 6 + 7; 
```

```csharp
// цикл while
while x < 25 { 
	x = x + 1; 
	x = x * 2; 
}
// цикл for - всегда идет на увеличение с шагом == 1
for i=2,7 
	a = a + i;
```

```csharp
input(a); // оператор ввода
print(a,b,c,d); // оператор вывода
```

```csharp
goto 777; // оператор безусловного перехода
//переход по метке
777: while (b < 20) 
    b = a + 5; 
```

Пример файла описания лексического анализатора (SimpleLex.lex)
```csharp
{INTNUM} { 
  yylval.iVal = int.Parse(yytext); 
  return (int)Tokens.INUM; 
}

"=" { return (int)Tokens.ASSIGN; }
";"  { return (int)Tokens.SEMICOLON; }
"+" {return (int)Tokens.PLUS; }
```

Пример файла описания синтаксического анализатора (SimpleYacc.y)
```csharp
%token <iVal> INUM
%token <bVal> BOOL
%token <sVal> ID

%type <eVal> expr ident A B C E T F exprlist
%type <stVal> assign statement for while if input print varlist var labelstatement goto block

stlist	: statement { $$ = new StListNode($1); }
		| stlist statement 
			{ 
				$1.Add($2); 
				$$ = $1; 
			}
		;
statement: assign SEMICOLON { $$ = $1; }
		| for { $$ = $1; }
		| while { $$ = $1; }
		| if { $$ = $1; }
		| block { $$ = $1; }
		| input SEMICOLON { $$ = $1; }
		| print SEMICOLON { $$ = $1; }
		| var SEMICOLON { $$ = $1; }
		| goto SEMICOLON { $$ = $1; }
		| labelstatement { $$ = $1; }
		;
```
Здесь в фигурных скобках указываются семантические действия (действия, происходящие для каждого распознанного правила грамматики и придающие смысл переводу программы в промежуточное представление).

### Абстрактное синтаксическое дерево
В АСТ включаются узлы, соответствующие всем конструкциям языка. В узел записываются его существенные атрибуты. Например, для узла унарной операции `UnOpNode` такими атрибутами являются `Expr` и `Op` - соответственно выражение и операция, применяющаяся к этому выражению.  

```csharp
public class UnOpNode : ExprNode
    {
        public ExprNode Expr
        {
            get { return ExprChildren[0]; }
            set { ExprChildren[0] = value; }
        }
        public OpType Op { get; set; }
        public UnOpNode(ExprNode expr, OpType op)
        {
            Op = op;
            ExprChildren.Add(expr);
        }
    }
```

### Место в общем проекте (Интеграция)
Создание грамматики и парсера и построение АСТ являются первыми шагами в работе компилятора. 

### Пример работы
1. 
```charp
a = 5;
```
![Присваивание](0_Parser%26AST/pic1.png)
2.
```charp
if a > 10
    b = a / 2;
else {
    b = a + b;
    a = b;
}
```
![Условный оператор](0_Parser%26AST/pic2.png)
